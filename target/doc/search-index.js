var searchIndex = {};
searchIndex["mailparse"] = {"doc":"","items":[[3,"MailHeader","mailparse","A struct that represents a single header in the message.\nIt holds slices into the raw byte array passed to parse_mail, and so the\nlifetime of this struct must be contained within the lifetime of the raw\ninput. There are additional accessor functions on this struct to extract\nthe data as Rust strings.",null,null],[3,"ParsedContentType","","A struct to hold a more structured representation of the Content-Type header.\nThis is provided mostly as a convenience since this metadata is usually\nneeded to interpret the message body properly.",null,null],[12,"mimetype","","The type of the data, for example &quot;text/plain&quot; or &quot;application/pdf&quot;.",0,null],[12,"charset","","The charset used to decode the raw byte data, for example &quot;iso-8859-1&quot;\nor &quot;utf-8&quot;.",0,null],[12,"boundary","","The boundary used to separate the different parts of a multipart message.\nThis boundary is taken straight from the Content-Type header, and so\nthe body will actually contain the boundary string prefixed by two\ndashes.",0,null],[3,"ParsedMail","","Struct that holds the structured representation of the message. Note that\nsince MIME allows for nested multipart messages, a tree-like structure is\nnecessary to represent it properly. This struct accomplishes that by holding\na vector of other ParsedMail structures for the subparts.",null,null],[12,"headers","","The headers for the message (or message subpart).",1,null],[12,"ctype","","The Content-Type information for the message (or message subpart).",1,null],[12,"subparts","","The subparts of this message or subpart. This vector is only non-empty\nif ctype.mimetype starts with &quot;multipart/&quot;.",1,null],[4,"MailParseError","","An error type that represents the different kinds of errors that may be\nencountered during message parsing.",null,null],[13,"QuotedPrintableDecodeError","","Data that was specified as being in the quoted-printable transfer-encoding\ncould not be successfully decoded as quoted-printable data.",2,null],[13,"Base64DecodeError","","Data that was specified as being in the base64 transfer-encoding could\nnot be successfully decoded as base64 data.",2,null],[13,"EncodingError","","An error occurred when converting the raw byte data to Rust UTF-8 string\nformat using the charset specified in the message.",2,null],[13,"Generic","","Some other error occurred while parsing the message; the description string\nprovides additional details.",2,null],[5,"dateparse","","Convert a date field from an email header into a UNIX epoch timestamp.\nThis function handles the most common formatting of date fields found in\nemail headers. It may fail to parse some of the more creative formattings.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"parse_header","","Parse a single header from the raw data given.\nThis function takes raw byte data, and starts parsing it, expecting there\nto be a MIME header key-value pair right at the beginning. It parses that\nheader and returns it, along with the index at which the next header is\nexpected to start. If you just want to parse a single header, you can ignore\nthe second component of the tuple, which is the index of the next header.\nError values are returned if the data could not be successfully interpreted\nas a MIME key-value pair.",null,null],[5,"parse_headers","","Parses all the headers from the raw data given.\nThis function takes raw byte data, and starts parsing it, expecting there\nto be zero or more MIME header key-value pair right at the beginning,\nfollowed by two consecutive newlines (i.e. a blank line). It parses those\nheaders and returns them in a vector. The normal vector functions can be\nused to access the headers linearly, or the MailHeaderMap trait can be used\nto access them in a map-like fashion. Along with this vector, the function\nreturns the index at which the message body is expected to start. If you\njust care about the headers, you can ignore the second component of the\nreturned tuple.\nError values are returned if there was some sort of parsing error.",null,null],[5,"parse_content_type","","Helper method to parse a header value as a Content-Type header. The charset\ndefaults to &quot;us-ascii&quot; if no charset parameter is provided in the header\nvalue.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"parse_mail","","The main mail-parsing entry point.\nThis function takes the raw data making up the message body and returns a\nstructured version of it, which allows easily accessing the header and body\ninformation as needed.",null,null],[8,"MailHeaderMap","","A trait that is implemented by the Vec&lt;MailHeader&gt; returned by the parse_headers\nfunction. It provides a map-like interface to look up header values by their\nname.",null,null],[10,"get_first_value","","Look through the list of headers and return the value of the first one\nthat matches the provided key. It returns Ok(None) if the no matching\nheader was found.",3,{"inputs":[{"name":"mailheadermap"},{"name":"str"}],"output":{"name":"result"}}],[10,"get_first_value_ci","","Same as get_first_value, but does a case-insensitive search for the header.\nAccording to the spec the mail headers are supposed to be case-sensitive,\nbut in real-world scenarios that&#39;s not always the case.",3,{"inputs":[{"name":"mailheadermap"},{"name":"str"}],"output":{"name":"result"}}],[10,"get_all_values","","Look through the list of headers and return the values of all headers\nmatching the provided key. Returns an empty vector if no matching headers\nwere found. The order of the returned values is the same as the order\nof the matching headers in the message.",3,{"inputs":[{"name":"mailheadermap"},{"name":"str"}],"output":{"name":"result"}}],[10,"get_all_values_ci","","Same as get_all_values, but does a case-insensitive search for the header.\nAccording to the spec the mail headers are supposed to be case-sensitive,\nbut in real-world scenarios that&#39;s not always the case.",3,{"inputs":[{"name":"mailheadermap"},{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"mailparseerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"mailparseerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",2,{"inputs":[{"name":"mailparseerror"}],"output":{"name":"str"}}],[11,"cause","","",2,{"inputs":[{"name":"mailparseerror"}],"output":{"name":"option"}}],[11,"from","","",2,{"inputs":[{"name":"quotedprintableerror"}],"output":{"name":"mailparseerror"}}],[11,"from","","",2,{"inputs":[{"name":"base64error"}],"output":{"name":"mailparseerror"}}],[11,"from","","",2,{"inputs":[{"name":"cow"}],"output":{"name":"mailparseerror"}}],[11,"fmt","","",4,{"inputs":[{"name":"mailheader"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"get_key","","Get the name of the header. Note that header names are case-sensitive.",4,{"inputs":[{"name":"mailheader"}],"output":{"name":"result"}}],[11,"get_value","","Get the value of the header. Any sequences of newlines characters followed\nby whitespace are collapsed into a single space. In effect, header values\nwrapped across multiple lines are compacted back into one line, while\ndiscarding the extra whitespace required by the MIME format. Additionally,\nany quoted-printable words in the value are decoded.",4,{"inputs":[{"name":"mailheader"}],"output":{"name":"result"}}],[11,"get_first_value","collections::vec","",5,{"inputs":[{"name":"vec"},{"name":"str"}],"output":{"name":"result"}}],[11,"get_first_value_ci","","",5,{"inputs":[{"name":"vec"},{"name":"str"}],"output":{"name":"result"}}],[11,"get_all_values","","",5,{"inputs":[{"name":"vec"},{"name":"str"}],"output":{"name":"result"}}],[11,"get_all_values_ci","","",5,{"inputs":[{"name":"vec"},{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","mailparse","",0,{"inputs":[{"name":"parsedcontenttype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"parsedmail"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"get_body","","Get the body of the message as a Rust string. This function tries to\nunapply the Content-Transfer-Encoding if there is one, and then converts\nthe result into a Rust UTF-8 string using the charset in the Content-Type\n(or &quot;us-ascii&quot; if the charset was missing or not recognized).",1,{"inputs":[{"name":"parsedmail"}],"output":{"name":"result"}}]],"paths":[[3,"ParsedContentType"],[3,"ParsedMail"],[4,"MailParseError"],[8,"MailHeaderMap"],[3,"MailHeader"],[3,"Vec"]]};
initSearch(searchIndex);
